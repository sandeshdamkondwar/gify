{"version":3,"sources":["components/GIFPlayer/GIFPlayer.tsx","images/loader.svg","project.config.js","components/GIFContainer/GIFContainer.tsx","hooks/useInfiniteScroller.ts","routes/Trending/Trending.tsx"],"names":["GifPlayer","gif","still","title","className","single","height","autoPlay","refPlaceholder","React","useRef","useState","playing","setplaying","toggle","useCallback","removePlaceholder","current","remove","classes","classNames","imageAttr","src","onLoad","onError","key","imageHeight","Math","floor","PADDING","onClick","style","data-test-id","ref","data-testid","alt","module","exports","getImagesLimit","windowWidth","CONFIG","memo","fetchGifs","cols","setCols","offset","setOffset","colHeights","setColHeights","scollThreshold","bottomThreshold","fetching","setFetching","reqAnimationFrameId","setReqAnimationFrameId","useEffect","threshold","window","pageYOffset","innerHeight","ticking","updateScrollPosition","scrollY","totalHeight","document","body","clientHeight","abs","onScroll","requestAnimationFrame","addEventListener","removeEventListener","cancelAnimationFrame","fetch","useInifiniteScroller","delayedLoading","debounce","offsetLimit","innerWidth","then","res","generateCols","data","Array","screenWidth","getNoOfCols","items","heights","mergedHeights","length","map","colHeight","idx","mergedCols","col","imageContainerHeight","max","colItems","colItem","itemKey","GIFPlayer","url","loader","gf","GiphyFetch","pageOffset","limit","trending"],"mappings":"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","file":"static/js/5.df5e5ad1.chunk.js","sourcesContent":["import React, { useState, useCallback } from \"react\";\nimport classNames from \"classnames\";\n\nconst PADDING = 5;\ninterface IGIFPlayerProps {\n  gif: string;\n  still: string;\n  height: number;\n  title: string;\n  className?: string;\n  single?: boolean;\n  autoPlay?: boolean;\n}\n\nconst GifPlayer = ({\n  gif,\n  still,\n  title,\n  className,\n  single,\n  height,\n  autoPlay = false,\n}: IGIFPlayerProps) => {\n  const refPlaceholder = React.useRef<HTMLDivElement>(null);\n  const [playing, setplaying] = useState(autoPlay);\n\n  const toggle = useCallback(() => {\n    if (autoPlay) return;\n    setplaying(!playing);\n  }, [autoPlay, playing]);\n\n  const removePlaceholder = useCallback(() => {\n    refPlaceholder?.current?.remove();\n  }, []);\n\n  const classes = classNames(\"gif_player\", className || \"\", {\n    playing: playing,\n    single: single,\n  });\n\n  let imageAttr: any = {\n    src: playing ? gif || still : still || gif,\n    onLoad: removePlaceholder,\n    onError: removePlaceholder,\n  };\n\n  if (single) {\n    imageAttr.key = imageAttr.src;\n  }\n\n  const imageHeight = Math.floor(height - PADDING * 2);\n  imageAttr.height = imageHeight;\n\n  return (\n    <div\n      className={classes}\n      onClick={toggle}\n      style={{ height: `${imageHeight}px` }}\n    >\n      <div className=\"play_button\" data-test-id={title}></div>\n\n      <div className=\"placeholder\" ref={refPlaceholder}></div>\n      <img data-testid=\"gif-image\" {...imageAttr} alt={title} />\n    </div>\n  );\n};\n\nexport default GifPlayer;\n","module.exports = __webpack_public_path__ + \"static/media/loader.77228bc8.svg\";","export default {\n  IMAGE_LOADING_LIMIT: 100,\n  IMAGE_LOADING_LIMIT_DESKTOP: 100,\n  LOADER_BOTTOM_THRESHOLD: 300,\n  SCROLL_LISTENER_THRESHOLD: 50,\n  LOADER_DEBOUNCE_TIME_IN_MS: 1000,\n};\n","import React, { useEffect, useState, useRef } from \"react\";\n\n// Helpers\nimport { debounce, generateCols, getNoOfCols } from \"../../helpers/\";\n\n// Hooks\nimport { useInifiniteScroller } from \"../../hooks/useInfiniteScroller\";\n\n// Defs\nimport { IGifItem } from \"../../defs/interfaces\";\n\n// Components\nimport GIFPlayer from \"../../components/GIFPlayer\";\nimport loader from \"../../images/loader.svg\";\nimport CONFIG from \"../../project.config\";\n\nconst getImagesLimit = (windowWidth: number) => {\n  return windowWidth < 500\n    ? CONFIG.IMAGE_LOADING_LIMIT\n    : CONFIG.IMAGE_LOADING_LIMIT_DESKTOP;\n};\n\nfunction GIFContainer({\n  fetchGifs,\n}: {\n  fetchGifs: (offset: number, limit: number) => Promise<any>;\n}) {\n  const [cols, setCols] = useState<any[]>([]);\n  const [offset, setOffset] = useState<number>(0);\n\n  const [colHeights, setColHeights] = useState<number[]>([]);\n  const { fetch, setFetching } = useInifiniteScroller({\n    scollThreshold: CONFIG.SCROLL_LISTENER_THRESHOLD,\n    bottomThreshold: CONFIG.LOADER_BOTTOM_THRESHOLD,\n  });\n\n  const delayedLoading = useRef(\n    debounce(\n      () => {\n        const offsetLimit = getImagesLimit(window.innerWidth);\n        // Updating offset will take care of fetching data with new offset\n        setOffset((offset) => {\n          return offset + offsetLimit + 1;\n        });\n      },\n      CONFIG.LOADER_DEBOUNCE_TIME_IN_MS,\n      false\n    )\n  ).current;\n\n  useEffect(() => {\n    const windowWidth = window.innerWidth;\n\n    const offsetLimit = getImagesLimit(windowWidth);\n    fetchGifs(offset, offsetLimit).then((res: any) => {\n      let { items, heights } = generateCols({\n        data: res.data instanceof Array ? res.data : [res.data],\n        screenWidth: windowWidth,\n        cols: getNoOfCols(windowWidth),\n      });\n\n      // Merge heights\n      const mergedHeights =\n        colHeights.length === 0\n          ? colHeights.map((colHeight, idx) => colHeight + heights[idx])\n          : heights;\n\n      setColHeights(mergedHeights);\n\n      // Merge with old result\n      items = items || [];\n      const mergedCols = cols.length\n        ? cols.map((col, idx) => [...cols[idx], ...items[idx]])\n        : items;\n\n      setCols(mergedCols);\n      setFetching(false);\n    });\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fetchGifs, offset]);\n\n  if (fetch && cols.length > 0) {\n    delayedLoading();\n  }\n\n  const imageContainerHeight = Math.max(...colHeights);\n\n  return (\n    <div className=\"gif-items-container\">\n      <div\n        className=\"gif-items-cols\"\n        style={{ height: `${imageContainerHeight}px` }}\n      >\n        {cols.map((colItems: Array<any>, key: number) => {\n          return (\n            <div key={key} className=\"gif-items-col\">\n              {colItems.map((colItem: IGifItem, itemKey: number) => (\n                <GIFPlayer\n                  className=\"gif-item\"\n                  key={itemKey}\n                  gif={colItem.gif.url}\n                  still={colItem.still.url}\n                  title={colItem.title}\n                  height={colItem.height}\n                />\n              ))}\n            </div>\n          );\n        })}\n      </div>\n      {fetch && <img src={loader} className=\"loader-image\" alt=\"loader\" />}\n    </div>\n  );\n}\n\nexport default React.memo(GIFContainer);\n","import { useState, useEffect } from \"react\";\n\ninterface IProps {\n  scollThreshold: number;\n  bottomThreshold: number;\n}\n\nexport const useInifiniteScroller = ({\n  scollThreshold,\n  bottomThreshold,\n}: IProps) => {\n  const [fetching, setFetching] = useState(false);\n  const [reqAnimationFrameId, setReqAnimationFrameId] = useState(0);\n\n  useEffect(() => {\n    const threshold = scollThreshold || 0;\n    let { pageYOffset, innerHeight } = window;\n    let ticking = false;\n\n    const updateScrollPosition = () => {\n      const scrollY = window.pageYOffset;\n      const totalHeight = document.body.clientHeight;\n\n      if (Math.abs(scrollY - pageYOffset) < threshold) {\n        // We haven't exceeded the threshold\n        ticking = false;\n        return;\n      }\n\n      pageYOffset = scrollY > 0 ? scrollY : 0;\n      ticking = false;\n\n      if (!fetching) {\n        const clientBottomPosition = scrollY + innerHeight;\n        const reachedDown =\n          totalHeight - clientBottomPosition < bottomThreshold;\n        if (reachedDown) {\n          setFetching(true);\n        } else {\n          setFetching(false);\n        }\n      }\n    };\n\n    const onScroll = () => {\n      if (!ticking) {\n        setReqAnimationFrameId(\n          window.requestAnimationFrame(updateScrollPosition)\n        );\n        ticking = true;\n      }\n    };\n\n    window.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll);\n      window.cancelAnimationFrame(reqAnimationFrameId);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    fetch: fetching,\n    setFetching,\n  };\n};\n","import React, { useCallback } from \"react\";\nimport { GiphyFetch } from \"@giphy/js-fetch-api\";\n\n// Components\nimport GIFContainer from \"../../components/GIFContainer\";\n\nconst GIPHY_KEY = \"dLTulzVpNZqXjYVV7bCY7SAW2cpASWSk\";\nconst gf = new GiphyFetch(GIPHY_KEY);\n\nfunction Trending() {\n  const fetchGifs = useCallback((pageOffset: number, limit: number) => {\n    return gf.trending({ offset: pageOffset, limit: limit });\n  }, []);\n\n  return (\n    <div>\n      <h3 className=\"page-heading\">Trending...</h3>\n      <GIFContainer fetchGifs={fetchGifs} />\n    </div>\n  );\n}\n\nexport default React.memo(Trending);\n"],"sourceRoot":""}