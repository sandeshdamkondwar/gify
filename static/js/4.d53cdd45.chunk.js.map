{"version":3,"sources":["components/GIFPlayer/GIFPlayer.tsx","hooks/useInfiniteScroller.ts","components/GIFContainer/GIFContainer.tsx","hooks/useWindowSize.ts","routes/Home/Home.tsx"],"names":["GifPlayer","gif","still","title","className","single","height","autoPlay","refPlaceholder","React","useRef","useState","playing","setplaying","toggle","useCallback","removePlaceholder","current","remove","classes","classNames","imageAttr","src","onLoad","onError","key","onClick","style","PADDING","data-test-id","ref","data-testid","alt","memo","fetchGifs","cols","setCols","offset","windowSize","width","setWindowSize","useEffect","handleResize","window","innerWidth","innerHeight","addEventListener","removeEventListener","useWindowSize","setHeight","lastScroll","thresholdPixels","setLastScroll","reqAnimationFrameId","setReqAnimationFrameId","threshold","lastScrollY","pageYOffset","ticking","updateScrollPosition","scrollY","Math","abs","onScroll","requestAnimationFrame","cancelAnimationFrame","useInifiniteScroller","console","log","then","res","generateCols","data","Array","screenWidth","getNoOfCols","items","heights","max","map","colItems","colItem","itemKey","GIFPlayer","url","gf","GiphyFetch","process","useContext","AppContext","state","pageOffset","search","query","limit"],"mappings":"0KAkEeA,EApDG,SAAC,GAQK,IAPtBC,EAOqB,EAPrBA,IACAC,EAMqB,EANrBA,MACAC,EAKqB,EALrBA,MACAC,EAIqB,EAJrBA,UACAC,EAGqB,EAHrBA,OACAC,EAEqB,EAFrBA,OAEqB,IADrBC,gBACqB,SACfC,EAAiBC,IAAMC,OAAuB,MAD/B,EAESC,mBAASJ,GAFlB,mBAEdK,EAFc,KAELC,EAFK,KAIfC,EAASC,uBAAY,WACrBR,GACJM,GAAYD,KACX,CAACL,EAAUK,IAERI,EAAoBD,uBAAY,WAAO,IAAD,EAC5B,OAAdP,QAAc,IAAdA,GAAA,UAAAA,EAAgBS,eAAhB,SAAyBC,WACxB,IAEGC,EAAUC,IAAW,aAAchB,GAAa,GAAI,CACxDQ,QAASA,EACTP,OAAQA,IAGNgB,EAAiB,CACnBC,IAAKV,EAAUX,GAAOC,EAAQA,GAASD,EACvCsB,OAAQP,EACRQ,QAASR,GASX,OAJIX,IACFgB,EAAUI,IAAMJ,EAAUC,KAI1B,yBACElB,UAAWe,EACXO,QAASZ,EACTa,MAAO,CAAErB,OAAO,GAAD,OAAKA,EAASsB,GAAd,QAEf,yBAAKxB,UAAU,cAAcyB,eAAc1B,IAE3C,yBAAKC,UAAU,cAAc0B,IAAKtB,IAClC,uCAAKuB,cAAY,aAAgBV,EAAjC,CAA4CW,IAAK7B,Q,6GCvDhD,I,QC2DQM,UAAMwB,MAlDrB,YAII,IAHFC,EAGC,EAHDA,UAGC,EACuBvB,mBAAgB,IADvC,mBACMwB,EADN,KACYC,EADZ,OAEgBzB,mBAAiB,GAA3B0B,EAFN,oBAGKC,ECpBO,WAAyB,MAGF3B,mBAAS,CAC3C4B,MAAO,EACPjC,OAAQ,IAL4B,mBAG/BgC,EAH+B,KAGnBE,EAHmB,KA4BtC,OApBAC,qBAAU,WAER,SAASC,IAEPF,EAAc,CACZD,MAAOI,OAAOC,WACdtC,OAAQqC,OAAOE,cAWnB,OANAF,OAAOG,iBAAiB,SAAUJ,GAGlCA,IAGO,kBAAMC,OAAOI,oBAAoB,SAAUL,MACjD,IAEIJ,EDRYU,GAHlB,EAI2BrC,mBAAS,GAJpC,mBAIML,EAJN,KAIc2C,EAJd,KAKOC,EDlB0B,SAAC,GAAiC,IAA/BC,EAA8B,EAA9BA,gBAA8B,EAC/BxC,mBAAS,GADsB,mBAC5DuC,EAD4D,KAChDE,EADgD,OAEbzC,mBAAS,GAFI,mBAE5D0C,EAF4D,KAEvCC,EAFuC,KAyCnE,OArCAb,qBAAU,WACR,IAAMc,EAAYJ,GAAmB,EACjCK,EAAcb,OAAOc,YACrBC,GAAU,EAERC,EAAuB,WAC3B,IAAMC,EAAUjB,OAAOc,YAEnBI,KAAKC,IAAIF,EAAUJ,GAAeD,EAEpCG,GAAU,GAKZA,GAAU,EACVN,EAFAI,EAAcI,EAAU,EAAIA,EAAU,KAKlCG,EAAW,WACVL,IACHJ,EACEX,OAAOqB,sBAAsBL,IAE/BD,GAAU,IAMd,OAFAf,OAAOG,iBAAiB,SAAUiB,GAE3B,WACLpB,OAAOI,oBAAoB,SAAUgB,GACrCpB,OAAOsB,qBAAqBZ,MAG7B,IAEI,CAAEH,cCvBcgB,CAAqB,CAC1Cf,gBAAiB,KADXD,WAmBR,OAfAiB,QAAQC,IAAIlB,GACZT,qBAAU,WACJH,EAAWC,MAAQ,GACrBL,EAAUG,GAAQgC,MAAK,SAACC,GAAc,IAAD,EACRC,YAAa,CACtCC,KAAMF,EAAIE,gBAAgBC,MAAQH,EAAIE,KAAO,CAACF,EAAIE,MAClDE,YAAapC,EAAWC,MACxBJ,KAAMwC,YAAYrC,EAAWC,SAHvBqC,EAD2B,EAC3BA,MAAOC,EADoB,EACpBA,QAKf5B,EAAUY,KAAKiB,IAAL,MAAAjB,KAAI,YAAQgB,KACtBzC,EAAQwC,QAGX,CAAC1C,EAAWG,EAAQC,IAGrB,yBAAKlC,UAAU,iBAAiBuB,MAAO,CAAErB,WACtC6B,EAAK4C,KAAI,SAACC,EAAsBvD,GAC/B,OACE,yBAAKA,IAAKA,EAAKrB,UAAU,iBACtB4E,EAASD,KAAI,SAACE,EAAmBC,GAApB,OACZ,kBAACC,EAAA,EAAD,CACE/E,UAAU,WACVqB,IAAKyD,EACLjF,IAAKgF,EAAQhF,IAAImF,IACjBlF,MAAO+E,EAAQ/E,MAAMkF,IACrBjF,MAAO8E,EAAQ9E,MACfG,OAAQ2E,EAAQ3E,qB,0FE7C1B+E,EAAK,IAAIC,aADGC,oCAyBH9E,cAAMwB,MAtBrB,WAAiB,IAAD,EACEuD,qBAAgBC,KAAzBC,EADO,oBAERxD,EAAYnB,uBAChB,SAAC4E,GACC,OAAON,EAAGO,OAAOF,EAAMG,MAAO,CAAExD,OAAQsD,EAAYG,MAAO,QAE7D,CAACJ,EAAMG,QAKT,QAFkBH,EAAMG,MAIpB,6BACE,wBAAIzF,UAAU,gBAAd,oBACA,kBAAC,IAAD,CAAc8B,UAAWA,KAIxB,wBAAI9B,UAAU,uBAAd","file":"static/js/4.d53cdd45.chunk.js","sourcesContent":["import React, { useState, useCallback } from \"react\";\nimport classNames from \"classnames\";\n\nconst PADDING = 5;\ninterface IGIFPlayerProps {\n  gif: string;\n  still: string;\n  height: number;\n  title: string;\n  className?: string;\n  single?: boolean;\n  autoPlay?: boolean;\n}\n\nconst GifPlayer = ({\n  gif,\n  still,\n  title,\n  className,\n  single,\n  height,\n  autoPlay = false,\n}: IGIFPlayerProps) => {\n  const refPlaceholder = React.useRef<HTMLDivElement>(null);\n  const [playing, setplaying] = useState(autoPlay);\n\n  const toggle = useCallback(() => {\n    if (autoPlay) return;\n    setplaying(!playing);\n  }, [autoPlay, playing]);\n\n  const removePlaceholder = useCallback(() => {\n    refPlaceholder?.current?.remove();\n  }, []);\n\n  const classes = classNames(\"gif_player\", className || \"\", {\n    playing: playing,\n    single: single,\n  });\n\n  let imageAttr: any = {\n    src: playing ? gif || still : still || gif,\n    onLoad: removePlaceholder,\n    onError: removePlaceholder,\n  };\n\n  // imageAttr.height = height;\n\n  if (single) {\n    imageAttr.key = imageAttr.src;\n  }\n\n  return (\n    <div\n      className={classes}\n      onClick={toggle}\n      style={{ height: `${height - PADDING * 2}px` }}\n    >\n      <div className=\"play_button\" data-test-id={title}></div>\n\n      <div className=\"placeholder\" ref={refPlaceholder}></div>\n      <img data-testid=\"gif-image\" {...imageAttr} alt={title} />\n    </div>\n  );\n};\n\nexport default GifPlayer;\n","import { useState, useEffect } from \"react\";\n\ninterface IProps {\n  thresholdPixels: number;\n}\n\nexport const useInifiniteScroller = ({ thresholdPixels }: IProps) => {\n  const [lastScroll, setLastScroll] = useState(0);\n  const [reqAnimationFrameId, setReqAnimationFrameId] = useState(0);\n\n  useEffect(() => {\n    const threshold = thresholdPixels || 0;\n    let lastScrollY = window.pageYOffset;\n    let ticking = false;\n\n    const updateScrollPosition = () => {\n      const scrollY = window.pageYOffset;\n\n      if (Math.abs(scrollY - lastScrollY) < threshold) {\n        // We haven't exceeded the threshold\n        ticking = false;\n        return;\n      }\n\n      lastScrollY = scrollY > 0 ? scrollY : 0;\n      ticking = false;\n      setLastScroll(lastScrollY);\n    };\n\n    const onScroll = () => {\n      if (!ticking) {\n        setReqAnimationFrameId(\n          window.requestAnimationFrame(updateScrollPosition)\n        );\n        ticking = true;\n      }\n    };\n\n    window.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll);\n      window.cancelAnimationFrame(reqAnimationFrameId);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return { lastScroll };\n};\n","import React, { useEffect, useState } from \"react\";\n\n// Helpers\nimport { generateCols, getNoOfCols } from \"../../helpers/\";\n\n// Hooks\nimport useWindowSize from \"../../hooks/useWindowSize\";\nimport { useInifiniteScroller } from \"../../hooks/useInfiniteScroller\";\n\n// Defs\nimport { IGifItem } from \"../../defs/interfaces\";\n\n// Components\nimport GIFPlayer from \"../../components/GIFPlayer\";\n\nfunction GIFContainer({\n  fetchGifs,\n}: {\n  fetchGifs: (offset: number) => Promise<any>;\n}) {\n  const [cols, setCols] = useState<any[]>([]);\n  const [offset] = useState<number>(0);\n  const windowSize = useWindowSize();\n  const [height, setHeight] = useState(0);\n  const { lastScroll } = useInifiniteScroller({\n    thresholdPixels: 20,\n  });\n\n  console.log(lastScroll);\n  useEffect(() => {\n    if (windowSize.width > 0) {\n      fetchGifs(offset).then((res: any) => {\n        const { items, heights } = generateCols({\n          data: res.data instanceof Array ? res.data : [res.data],\n          screenWidth: windowSize.width,\n          cols: getNoOfCols(windowSize.width),\n        });\n        setHeight(Math.max(...heights));\n        setCols(items);\n      });\n    }\n  }, [fetchGifs, offset, windowSize]);\n\n  return (\n    <div className=\"gif-items-cols\" style={{ height }}>\n      {cols.map((colItems: Array<any>, key: number) => {\n        return (\n          <div key={key} className=\"gif-items-col\">\n            {colItems.map((colItem: IGifItem, itemKey: number) => (\n              <GIFPlayer\n                className=\"gif-item\"\n                key={itemKey}\n                gif={colItem.gif.url}\n                still={colItem.still.url}\n                title={colItem.title}\n                height={colItem.height}\n              />\n            ))}\n          </div>\n        );\n      })}\n    </div>\n  );\n}\n\nexport default React.memo(GIFContainer);\n","import { useState, useEffect } from \"react\";\n\nexport default function useWindowSize() {\n  // Initialize state with undefined width/height so server and client renders match\n  // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\n  const [windowSize, setWindowSize] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  useEffect(() => {\n    // Handler to call on window resize\n    function handleResize() {\n      // Set window width/height to state\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }\n\n    // Add event listener\n    window.addEventListener(\"resize\", handleResize);\n\n    // Call handler right away so state gets updated with initial window size\n    handleResize();\n\n    // Remove event listener on cleanup\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []); // Empty array ensures that effect is only run on mount\n\n  return windowSize;\n}\n","import React, { useCallback, useContext } from \"react\";\nimport { GiphyFetch } from \"@giphy/js-fetch-api\";\n\n// Components\nimport GIFContainer from \"../../components/GIFContainer\";\n\n// Contexts\nimport { AppContext } from \"../../contexts/App\";\n\nconst GIPHY_KEY = process.env.REACT_APP_GIPHY_ACCESS_KEY || \"\";\nconst gf = new GiphyFetch(GIPHY_KEY);\n\nfunction Home() {\n  const [state] = useContext<any>(AppContext);\n  const fetchGifs = useCallback(\n    (pageOffset: number) => {\n      return gf.search(state.query, { offset: pageOffset, limit: 100 });\n    },\n    [state.query]\n  );\n\n  const isQuery = !!state.query;\n\n  if (isQuery) {\n    return (\n      <div>\n        <h3 className=\"page-heading\">Search Result...</h3>\n        <GIFContainer fetchGifs={fetchGifs} />\n      </div>\n    );\n  }\n  return <h3 className=\"page-heading-center\">Search Your GIF Above...</h3>;\n}\n\nexport default React.memo(Home);\n"],"sourceRoot":""}