{"version":3,"sources":["components/GIFPlayer/GIFPlayer.tsx","images/loader.svg","hooks/useInfiniteScroller.ts","project.config.js","components/GIFContainer/GIFContainer.tsx","hooks/useWindowSize.ts","routes/Home/Home.tsx"],"names":["GifPlayer","gif","still","title","className","single","height","autoPlay","refPlaceholder","React","useRef","useState","playing","setplaying","toggle","useCallback","removePlaceholder","current","remove","classes","classNames","imageAttr","src","onLoad","onError","key","imageHeight","Math","floor","PADDING","onClick","style","data-test-id","ref","data-testid","alt","module","exports","getImagesLimit","windowWidth","CONFIG","memo","fetchGifs","cols","setCols","offset","setOffset","windowSize","width","setWindowSize","useEffect","handleResize","window","innerWidth","innerHeight","addEventListener","removeEventListener","useWindowSize","colHeights","setColHeights","scollThreshold","bottomThreshold","fetching","setFetching","reqAnimationFrameId","setReqAnimationFrameId","threshold","pageYOffset","ticking","updateScrollPosition","scrollY","totalHeight","document","body","clientHeight","abs","onScroll","requestAnimationFrame","cancelAnimationFrame","fetch","useInifiniteScroller","delayedLoading","debounce","offsetLimit","then","res","generateCols","data","Array","screenWidth","getNoOfCols","items","heights","mergedHeights","length","map","colHeight","idx","mergedCols","col","imageContainerHeight","max","colItems","colItem","itemKey","GIFPlayer","url","loader","gf","GiphyFetch","process","useContext","AppContext","state","pageOffset","limit","search","query"],"mappings":"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","file":"static/js/4.64c2be81.chunk.js","sourcesContent":["import React, { useState, useCallback } from \"react\";\nimport classNames from \"classnames\";\n\nconst PADDING = 5;\ninterface IGIFPlayerProps {\n  gif: string;\n  still: string;\n  height: number;\n  title: string;\n  className?: string;\n  single?: boolean;\n  autoPlay?: boolean;\n}\n\nconst GifPlayer = ({\n  gif,\n  still,\n  title,\n  className,\n  single,\n  height,\n  autoPlay = false,\n}: IGIFPlayerProps) => {\n  const refPlaceholder = React.useRef<HTMLDivElement>(null);\n  const [playing, setplaying] = useState(autoPlay);\n\n  const toggle = useCallback(() => {\n    if (autoPlay) return;\n    setplaying(!playing);\n  }, [autoPlay, playing]);\n\n  const removePlaceholder = useCallback(() => {\n    refPlaceholder?.current?.remove();\n  }, []);\n\n  const classes = classNames(\"gif_player\", className || \"\", {\n    playing: playing,\n    single: single,\n  });\n\n  let imageAttr: any = {\n    src: playing ? gif || still : still || gif,\n    onLoad: removePlaceholder,\n    onError: removePlaceholder,\n  };\n\n  // imageAttr.height = height;\n\n  if (single) {\n    imageAttr.key = imageAttr.src;\n  }\n\n  const imageHeight = Math.floor(height - PADDING * 2);\n\n  return (\n    <div\n      className={classes}\n      onClick={toggle}\n      style={{ height: `${imageHeight}px` }}\n    >\n      <div className=\"play_button\" data-test-id={title}></div>\n\n      <div className=\"placeholder\" ref={refPlaceholder}></div>\n      <img data-testid=\"gif-image\" {...imageAttr} alt={title} />\n    </div>\n  );\n};\n\nexport default GifPlayer;\n","module.exports = __webpack_public_path__ + \"static/media/loader.77228bc8.svg\";","import { useState, useEffect } from \"react\";\n\ninterface IProps {\n  scollThreshold: number;\n  bottomThreshold: number;\n}\n\nexport const useInifiniteScroller = ({\n  scollThreshold,\n  bottomThreshold,\n}: IProps) => {\n  const [fetching, setFetching] = useState(false);\n  const [reqAnimationFrameId, setReqAnimationFrameId] = useState(0);\n\n  useEffect(() => {\n    const threshold = scollThreshold || 0;\n    let { pageYOffset, innerHeight } = window;\n    let ticking = false;\n\n    const updateScrollPosition = () => {\n      const scrollY = window.pageYOffset;\n      const totalHeight = document.body.clientHeight;\n\n      if (Math.abs(scrollY - pageYOffset) < threshold) {\n        // We haven't exceeded the threshold\n        ticking = false;\n        return;\n      }\n\n      pageYOffset = scrollY > 0 ? scrollY : 0;\n      ticking = false;\n\n      if (!fetching) {\n        const clientBottomPosition = scrollY + innerHeight;\n        const reachedDown =\n          totalHeight - clientBottomPosition < bottomThreshold;\n        if (reachedDown) {\n          setFetching(true);\n        } else {\n          setFetching(false);\n        }\n      }\n    };\n\n    const onScroll = () => {\n      if (!ticking) {\n        setReqAnimationFrameId(\n          window.requestAnimationFrame(updateScrollPosition)\n        );\n        ticking = true;\n      }\n    };\n\n    window.addEventListener(\"scroll\", onScroll);\n\n    return () => {\n      window.removeEventListener(\"scroll\", onScroll);\n      window.cancelAnimationFrame(reqAnimationFrameId);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    fetch: fetching,\n    setFetching,\n  };\n};\n","export default {\n  IMAGE_LOADING_LIMIT: 100,\n  IMAGE_LOADING_LIMIT_DESKTOP: 100,\n  LOADER_BOTTOM_THRESHOLD: 300,\n  SCROLL_LISTENER_THRESHOLD: 50,\n  LOADER_DEBOUNCE_TIME_IN_MS: 1000,\n};\n","import React, { useEffect, useState, useRef } from \"react\";\n\n// Helpers\nimport { debounce, generateCols, getNoOfCols } from \"../../helpers/\";\n\n// Hooks\nimport useWindowSize from \"../../hooks/useWindowSize\";\nimport { useInifiniteScroller } from \"../../hooks/useInfiniteScroller\";\n\n// Defs\nimport { IGifItem } from \"../../defs/interfaces\";\n\n// Components\nimport GIFPlayer from \"../../components/GIFPlayer\";\nimport loader from \"../../images/loader.svg\";\nimport CONFIG from \"../../project.config\";\n\nconst getImagesLimit = (windowWidth: number) => {\n  return windowWidth < 500\n    ? CONFIG.IMAGE_LOADING_LIMIT\n    : CONFIG.IMAGE_LOADING_LIMIT_DESKTOP;\n};\n\nfunction GIFContainer({\n  fetchGifs,\n}: {\n  fetchGifs: (offset: number, limit: number) => Promise<any>;\n}) {\n  const [cols, setCols] = useState<any[]>([]);\n  const [offset, setOffset] = useState<number>(0);\n  const windowSize = useWindowSize();\n  const [colHeights, setColHeights] = useState<number[]>([]);\n  const { fetch, setFetching } = useInifiniteScroller({\n    scollThreshold: CONFIG.SCROLL_LISTENER_THRESHOLD,\n    bottomThreshold: CONFIG.LOADER_BOTTOM_THRESHOLD,\n  });\n\n  const delayedLoading = useRef(\n    debounce(\n      () => {\n        const offsetLimit = getImagesLimit(windowSize.width);\n        // Updating offset will take care of fetching data with new offset\n        setOffset((offset) => {\n          return offset + offsetLimit + 1;\n        });\n      },\n      CONFIG.LOADER_DEBOUNCE_TIME_IN_MS,\n      false\n    )\n  ).current;\n\n  useEffect(() => {\n    if (windowSize.width > 0) {\n      const offsetLimit = getImagesLimit(windowSize.width);\n      fetchGifs(offset, offsetLimit).then((res: any) => {\n        let { items, heights } = generateCols({\n          data: res.data instanceof Array ? res.data : [res.data],\n          screenWidth: windowSize.width,\n          cols: getNoOfCols(windowSize.width),\n        });\n\n        // Merge heights\n        const mergedHeights =\n          colHeights.length === 0\n            ? colHeights.map((colHeight, idx) => colHeight + heights[idx])\n            : heights;\n\n        setColHeights(mergedHeights);\n\n        // Merge with old result\n        items = items || [];\n        const mergedCols = cols.length\n          ? cols.map((col, idx) => [...cols[idx], ...items[idx]])\n          : items;\n\n        setCols(mergedCols);\n        setFetching(false);\n      });\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fetchGifs, offset, windowSize]);\n\n  if (fetch && cols.length > 0) {\n    delayedLoading();\n  }\n\n  const imageContainerHeight = Math.max(...colHeights);\n\n  return (\n    <div className=\"gif-items-container\">\n      <div\n        className=\"gif-items-cols\"\n        style={{ height: `${imageContainerHeight}px` }}\n      >\n        {cols.map((colItems: Array<any>, key: number) => {\n          return (\n            <div key={key} className=\"gif-items-col\">\n              {colItems.map((colItem: IGifItem, itemKey: number) => (\n                <GIFPlayer\n                  className=\"gif-item\"\n                  key={itemKey}\n                  gif={colItem.gif.url}\n                  still={colItem.still.url}\n                  title={colItem.title}\n                  height={colItem.height}\n                />\n              ))}\n            </div>\n          );\n        })}\n      </div>\n      {fetch && <img src={loader} className=\"loader-image\" alt=\"loader\" />}\n    </div>\n  );\n}\n\nexport default React.memo(GIFContainer);\n","import { useState, useEffect } from \"react\";\n\nexport default function useWindowSize() {\n  // Initialize state with undefined width/height so server and client renders match\n  // Learn more here: https://joshwcomeau.com/react/the-perils-of-rehydration/\n  const [windowSize, setWindowSize] = useState({\n    width: 0,\n    height: 0,\n  });\n\n  useEffect(() => {\n    // Handler to call on window resize\n    function handleResize() {\n      // Set window width/height to state\n      setWindowSize({\n        width: window.innerWidth,\n        height: window.innerHeight,\n      });\n    }\n\n    // Add event listener\n    window.addEventListener(\"resize\", handleResize);\n\n    // Call handler right away so state gets updated with initial window size\n    handleResize();\n\n    // Remove event listener on cleanup\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []); // Empty array ensures that effect is only run on mount\n\n  return windowSize;\n}\n","import React, { useCallback, useContext } from \"react\";\nimport { GiphyFetch } from \"@giphy/js-fetch-api\";\n\n// Components\nimport GIFContainer from \"../../components/GIFContainer\";\n\n// Contexts\nimport { AppContext } from \"../../contexts/App\";\n\nconst GIPHY_KEY = process.env.REACT_APP_GIPHY_ACCESS_KEY || \"\";\nconst gf = new GiphyFetch(GIPHY_KEY);\n\nfunction Home() {\n  const [state] = useContext<any>(AppContext);\n  const fetchGifs = useCallback(\n    (pageOffset: number, limit: number) => {\n      return gf.search(state.query, {\n        offset: pageOffset,\n        limit: limit,\n      });\n    },\n    [state.query]\n  );\n\n  const isQuery = !!state.query;\n\n  if (isQuery) {\n    return (\n      <div>\n        <h3 className=\"page-heading\">Search Result...</h3>\n        <GIFContainer fetchGifs={fetchGifs} />\n      </div>\n    );\n  }\n  return <h3 className=\"page-heading-center\">Search Your GIF Above...</h3>;\n}\n\nexport default React.memo(Home);\n"],"sourceRoot":""}